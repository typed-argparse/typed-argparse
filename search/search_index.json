{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"typed-argparse","text":"<p>\ud83d\udca1 write type-safe and elegant CLIs with a clear separation of concerns.</p> <p> </p>"},{"location":"#features","title":"Features","text":"<ul> <li>Argument parsing based on type annotation (including runtime validation).</li> <li>Support for many common types.</li> <li>Clear separation of concern between argument parsing and business logic.</li> <li>Support for super-low-latency shell auto-completions.</li> <li>Great for writing sub-command CLIs.</li> <li>Very lightweight.</li> <li>No dependencies.</li> <li>Fully typed itself, no extra type stubs required.</li> <li>Offers both a high-level and a low-level API.   The high-level API generally requires less code to write, is fully based on type annotations, and is the preferred way for writing new CLIs.   The low-level API is mainly a low-effort migration path for incorporating type-safety into existing CLIs based on <code>argparse</code>.</li> </ul>"},{"location":"#install","title":"Install","text":"<pre><code>$ pip install typed-argparse\n</code></pre> <p>The only requirement is a modern Python (3.8+).</p>"},{"location":"#next-step","title":"Next step","text":"<p>Continue with getting started.</p>"},{"location":"high_level_api/","title":"High-level API","text":""},{"location":"high_level_api/#getting-started","title":"Getting started","text":"<p>Writing apps with <code>typed_argparse</code> involves three steps, emphasizing a clear separation of concerns:</p> <ol> <li>Argument definition: This defines how argument parsing should work.</li> <li>Business logic: This defines what your app does.</li> <li>Bind &amp; run argument definition with business logic, typically in your top-level <code>main()</code> function.</li> </ol> basic_usage.py<pre><code>from typing import List, Optional\n\nimport typed_argparse as tap\n\n\n# 1. Argument definition\nclass Args(tap.TypedArgs):\n    my_arg: str = tap.arg(help=\"some help\")\n    number_a: int = tap.arg(default=42, help=\"some help\")\n    number_b: Optional[int] = tap.arg(help=\"some help\")\n    verbose: bool = tap.arg(help=\"some help\")\n    names: List[str] = tap.arg(help=\"some help\")\n\n\n# 2. Business logic\ndef runner(args: Args):\n    print(f\"Running my app with args:\\n{args}\")\n\n\n# 3. Bind argument definition + business logic &amp; run\ndef main() -&gt; None:\n    tap.Parser(Args).bind(runner).run()\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>Let's see it in action:</p> <pre><code>$ python basic_usage.py -h\nusage: basic_usage.py [-h] --my-arg MY_ARG [--number-a NUMBER_A]\n                      [--number-b NUMBER_B] [--verbose] --names\n                      [NAMES [NAMES ...]]\n\noptional arguments:\n  -h, --help            show this help message and exit\n  --my-arg MY_ARG       some help\n  --number-a NUMBER_A   some help \u001b[90m[default: 42]\u001b[39m\n  --number-b NUMBER_B   some help\n  --verbose             some help\n  --names [NAMES [NAMES ...]]\n                        some help\n\n$ python basic_usage.py --my-arg foo --names a b c\nRunning my app with args:\nArgs(my_arg='foo', number_a=42, number_b=None, verbose=False, names=['a', 'b', 'c'])\n</code></pre> <p>Some observations:</p> <ul> <li>By default, arguments are required and option-like.   The command line option corresponds to the Python variable name, with underscores replaces by hyphens.   For instance, <code>my_arg: str</code> is specified via <code>--my-arg &lt;value&gt;</code> on the command line.</li> <li>If an argument has a default it becomes optional (<code>number_a</code>).</li> <li>If an argument is type-annotated as <code>Optional[T]</code> it also becomes optional, but can take the value <code>None</code> (<code>number_b</code>)</li> <li>If an argument is type-annotated as <code>bool</code> it becomes as boolean switch.</li> <li>If an argument is type-annotated as <code>List[T]</code>, it becomes an <code>nargs=\"*\"</code> argument, i.e., it allows for zero or more values.</li> </ul>"},{"location":"high_level_api/#positional-arguments","title":"Positional arguments","text":"<p>By default arguments are option-like, i.e., if the field name is <code>some_argument</code> can be specified as <code>--some-argument &lt;value&gt;</code> on the command line.</p> <p>In order to create positional (unnamed) argument, <code>positional=True</code> can be passed to the <code>tap.arg</code> function. For instance:</p> positional_arguments.py<pre><code>from pathlib import Path\n\nimport typed_argparse as tap\n\n\nclass Args(tap.TypedArgs):\n    src: Path = tap.arg(positional=True, help=\"Source file\")\n    dst: Path = tap.arg(positional=True, help=\"Destination file\")\n\n\ndef runner(args: Args):\n    print(f\"Print copying from '{args.src}' to '{args.dst}'\")\n\n\ndef main() -&gt; None:\n    tap.Parser(Args).bind(runner).run()\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <pre><code>$ python positional_arguments.py -h\nusage: positional_arguments.py [-h] src dst\n\npositional arguments:\n  src         Source file\n  dst         Destination file\n\noptional arguments:\n  -h, --help  show this help message and exit\n\n$ python positional_arguments.py my_source_file my_destination_file\nPrint copying from 'my_source_file' to 'my_destination_file'\n</code></pre>"},{"location":"high_level_api/#multiple-positional-arguments","title":"Multiple positional arguments","text":"<p>Positional arguments can be turned into lists:</p> <ul> <li><code>nargs=*</code> corresponds to a list that can be empty, i.e., it is optional to specify any arguments.</li> <li><code>nargs=+</code> corresponds to a list that cannot be empty, i.e., at least one argument must be given.</li> </ul> <p>Using <code>nargs</code> implies that in terms of the type signature the arguments becomes a <code>some_argument: List[T]</code> instead of <code>some_argument: T</code>. Correct usage is verified by type_argparse's type signatures.</p> <p>For example the following would result in similar semantics like <code>mv</code> (multiple but non-zero inputs, single output):</p> positional_arguments.py<pre><code>from pathlib import Path\nfrom typing import List\n\nimport typed_argparse as tap\n\n\nclass Args(tap.TypedArgs):\n    sources: List[Path] = tap.arg(\n        positional=True,\n        help=\"Source path(s)\",\n        nargs=\"+\",\n    )\n    dest: Path = tap.arg(\n        positional=True,\n        help=\"Destination path\",\n    )\n\n\ndef runner(args: Args):\n    print(f\"Moving sources '{repr(args.sources)}' to dest '{repr(args.dest)}'\")\n\n\ndef main() -&gt; None:\n    tap.Parser(Args).bind(runner).run()\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <pre><code>$ python positional_arguments_non_optional.py -h\nusage: positional_arguments_non_optional.py [-h] sources [sources ...] dest\n\npositional arguments:\n  sources     Source path(s)\n  dest        Destination path\n\noptional arguments:\n  -h, --help  show this help message and exit\n\n$ python positional_arguments_non_optional.py source_a source_b my_dest\nMoving sources '[PosixPath('source_a'), PosixPath('source_b')]' to dest 'PosixPath('my_dest')'\n</code></pre>"},{"location":"high_level_api/#flags-renaming","title":"Flags &amp; renaming","text":"<p>The first argument passed to <code>tap.arg(...)</code> can be used to define short option short names, also known as flags. For instance <code>foo: str = tap.arg(\"-f\")</code> introduces the flag <code>-f</code> as a shorthand for <code>--foo</code>. Similar to regular argparse, multiple names/flags can be specified.</p> <p>Note</p> <p>As long as only a single letter flag like <code>-f</code> is introduced, the original option name (e.g. <code>--foo</code>) is still added. If any option name is not that is longer than one letter, the original optional name is omitted, i.e., the specified values become an override. This feature allows to use different names internally (Python) vs externally (CLI).</p> option_names.py<pre><code>import typed_argparse as tap\n\n\nclass Args(tap.TypedArgs):\n    foo: str = tap.arg(\"-f\")\n    internal_name: str = tap.arg(\"--external-name\")\n\n\ndef runner(args: Args):\n    print(f\"args = {args}\")\n\n\ndef main() -&gt; None:\n    tap.Parser(Args).bind(runner).run()\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <pre><code>$ python option_names.py -h\nusage: option_names.py [-h] -f FOO --external-name INTERNAL_NAME\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -f FOO, --foo FOO\n  --external-name INTERNAL_NAME\n\n$ python option_names.py -f xxx --external-name yyy\nargs = Args(foo='xxx', internal_name='yyy')\n</code></pre>"},{"location":"high_level_api/#sub-commands","title":"Sub-commands","text":"<p>Let's assume we want to write a complex CLI involving many, possible deeply nested, sub-commands (think <code>git</code>). For instance, imagine the an app that takes either <code>foo</code> or <code>bar</code> as the first level sub-command, and the <code>foo</code> sub-command is further split into <code>start</code> and <code>stop</code>, i.e. the possible command paths are:</p> <pre><code>$ demo_app foo start\n$ demo_app foo stop\n$ demo_app bar\n</code></pre> <p>In <code>typed_argparse</code> such a tree-like command structure can be directly modeled as a tree of parsers:</p> sub_commands_basic.py<pre><code>import typed_argparse as tap\n\n\nclass FooStartArgs(tap.TypedArgs):\n    ...\n\n\nclass FooStopArgs(tap.TypedArgs):\n    ...\n\n\nclass BarArgs(tap.TypedArgs):\n    ...\n\n\ndef run_foo_start(args: FooStartArgs) -&gt; None:\n    print(f\"Running foo start: {args}\")\n\n\ndef run_foo_stop(args: FooStopArgs) -&gt; None:\n    print(f\"Running foo stop: {args}\")\n\n\ndef run_bar(args: BarArgs) -&gt; None:\n    print(f\"Running bar: {args}\")\n\n\ndef main() -&gt; None:\n    # The tree-like structure of the CLI (foo -&gt; start, foo -&gt; stop, bar)\n    # is directly reflected in the parser structure:\n    tap.Parser(\n        tap.SubParserGroup(\n            tap.SubParser(\n                \"foo\",\n                tap.SubParserGroup(\n                    tap.SubParser(\"start\", FooStartArgs, help=\"Help of foo -&gt; start\"),\n                    tap.SubParser(\"stop\", FooStopArgs, help=\"Help of foo -&gt; stop\"),\n                ),\n                help=\"Help of foo\",\n            ),\n            tap.SubParser(\n                \"bar\",\n                BarArgs,\n                help=\"Help of bar\",\n            ),\n        ),\n    ).bind(\n        run_foo_start,\n        run_foo_stop,\n        run_bar,\n    ).run()\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <pre><code>$ python sub_commands_basic.py -h\nusage: sub_commands_basic.py [-h] {foo,bar} ...\n\noptional arguments:\n  -h, --help  show this help message and exit\n\nsubcommands:\n  {foo,bar}   Available sub commands\n    foo       Help of foo\n    bar       Help of bar\n\n$ python sub_commands_basic.py foo -h\nusage: sub_commands_basic.py foo [-h] {start,stop} ...\n\noptional arguments:\n  -h, --help    show this help message and exit\n\nsubcommands:\n  {start,stop}  Available sub commands\n    start       Help of foo -&gt; start\n    stop        Help of foo -&gt; stop\n\n$ python sub_commands_basic.py foo start\nRunning foo start: FooStartArgs()\n\n$ python sub_commands_basic.py foo stop\nRunning foo stop: FooStopArgs()\n\n$ python sub_commands_basic.py bar\nRunning bar: BarArgs()\n</code></pre> <p>Some observations:</p> <ul> <li>In general a <code>Parser</code> or a <code>SubParser</code> can either take a <code>TypedArg</code> object directly (with leads to no further nesting)   or a <code>SubParserGroup</code> container which in turn contains one or more <code>SubParser</code> commands (with adds one level of nesting).</li> <li>The general <code>Parser.bind().run()</code> pattern is the same as with shallow CLIs.   The main difference is that sub-commands CLIs bind a runner method for each \"leaf\" in the argument tree.</li> </ul> <p>Note</p> <p><code>typed_argparse</code> internally performs a correctness and completeness check on the functions passed to <code>Parser.bind()</code>. This makes sure that you cannot accidentally forget to bind a leaf of the argument tree, and that all argument types have a matching binding. If you plan to write unit tests for your CLI, including a call to <code>Parser.bind()</code> is therefore a sensible test that makes sure that everything is bound properly.</p>"},{"location":"high_level_api/#common-arguments-in-sub-commands","title":"Common arguments in sub-commands","text":"<p>If some arguments should be shared between multiple sub-commands, provide a base class with those arguments and have the class defining the arguments subclass this.</p> <p>In the example below, the common argumen is <code>--verbose</code> and <code>CommonArgs</code> just describes this argument. There are two options for how these options need to be passed on the command line. In the example, the two sub-commands <code>foo</code> and <code>bar</code> use the two options different options:</p> <ul> <li>For <code>foo</code> the <code>CommonArgs</code> are just used as subclass and not passed via the <code>common_args=...</code> argument to the subparser group.   The common arguments will be added to each command individually, i.e., usage becomes <code>&lt;myapp&gt; foo start --verbose</code> and <code>&lt;myapp&gt; foo stop --verbose</code>.</li> <li>For <code>bar</code> the <code>CommonArgs</code> are used as subclass and additionally passed as the <code>common_args=...</code> argument to the subparser group.   The common argument will be added at the parent level, i.e., usage becomes <code>&lt;myapp&gt; bar --verbose start</code> and <code>&lt;myapp&gt; bar --verbose stop</code>.</li> </ul> sub_commands_common_arguments.py<pre><code>import typed_argparse as tap\n\n\nclass CommonArgs(tap.TypedArgs):\n    verbose: bool = tap.arg(default=False, help=\"Enable verbose log output.\")\n\n\nclass FooStartArgs(CommonArgs):\n    ...\n\n\nclass FooStopArgs(CommonArgs):\n    ...\n\n\ndef run_foo_start(args: FooStartArgs) -&gt; None:\n    print(f\"Running foo start with {args} {'verbosely!' if args.verbose else ''}\")\n\n\ndef run_foo_stop(args: FooStopArgs) -&gt; None:\n    print(f\"Running foo stop with {args}\")\n\n\nclass BarStartArgs(CommonArgs):\n    ...\n\n\nclass BarStopArgs(CommonArgs):\n    ...\n\n\ndef run_bar_start(args: BarStartArgs) -&gt; None:\n    print(f\"Running bar start with {args} {'verbosely!' if args.verbose else ''}\")\n\n\ndef run_bar_stop(args: BarStopArgs) -&gt; None:\n    print(f\"Running bar stop with {args}\")\n\n\ndef main() -&gt; None:\n    tap.Parser(\n        tap.SubParserGroup(\n            tap.SubParser(\n                \"foo\",\n                tap.SubParserGroup(\n                    tap.SubParser(\"start\", FooStartArgs, help=\"Help of foo -&gt; start\"),\n                    tap.SubParser(\"stop\", FooStopArgs, help=\"Help of foo -&gt; stop\"),\n                ),\n                help=\"Help of foo\",\n            ),\n            tap.SubParser(\n                \"bar\",\n                tap.SubParserGroup(\n                    tap.SubParser(\"start\", BarStartArgs, help=\"Help of bar -&gt; start\"),\n                    tap.SubParser(\"stop\", BarStopArgs, help=\"Help of bar -&gt; stop\"),\n                    common_args=CommonArgs,\n                ),\n                help=\"Help of bar\",\n            ),\n        ),\n    ).bind(\n        run_foo_start,\n        run_foo_stop,\n        run_bar_start,\n        run_bar_stop,\n    ).run()\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>Compare the help output for the two different sub-commands:</p> <pre><code>$ python examples/high_level_api/sub_commands_common_arguments.py foo -h\nusage: sub_commands_common_arguments.py foo [-h] {start,stop} ...\n\noptions:\n  -h, --help    show this help message and exit\n\nsubcommands:\n  {start,stop}  Available sub commands\n    start       Help of foo -&gt; start\n    stop        Help of foo -&gt; stop\n\n$ python examples/high_level_api/sub_commands_common_arguments.py foo start -h\nusage: sub_commands_common_arguments.py foo start [-h] [--verbose]\n\noptions:\n  -h, --help  show this help message and exit\n  --verbose   Enable verbose log output. [default: False]\n\n$ python examples/high_level_api/sub_commands_common_arguments.py bar -h\nusage: sub_commands_common_arguments.py bar [-h] [--verbose] {start,stop} ...\n\noptions:\n  -h, --help    show this help message and exit\n  --verbose     Enable verbose log output. [default: False]\n\nsubcommands:\n  {start,stop}  Available sub commands\n    start       Help of bar -&gt; start\n    stop        Help of bar -&gt; stop\n\n$ python examples/high_level_api/sub_commands_common_arguments.py bar start -h\nusage: sub_commands_common_arguments.py bar start [-h]\n\noptions:\n  -h, --help  show this help message and exit\n\n\n$ python examples/high_level_api/sub_commands_common_arguments.py foo start --verbose\nRunning foo start with FooStartArgs(verbose=True) verbosely!\n\n$ python examples/high_level_api/sub_commands_common_arguments.py bar start --verbose\nusage: sub_commands_common_arguments.py [-h] {foo,bar} ...\nsub_commands_common_arguments.py: error: unrecognized arguments: --verbose\n$ python examples/high_level_api/sub_commands_common_arguments.py bar --verbose start                                                                                                               2 \u21b5\nRunning bar start with BarStartArgs(verbose=True) verbosely!\n</code></pre>"},{"location":"high_level_api/#auto-completion","title":"Auto-completion","text":"<p><code>typed_argparse</code> builds on top of <code>argcomplete</code> for auto-completion. The rule is: If you have <code>argcomplete</code> installed, <code>typed_argparse</code> detects it and automatically installs the auto-completion. Check the <code>argcomplete</code> documentation how to activate <code>argcomplete</code> for your particular shell flavor.</p>"},{"location":"high_level_api/#enums","title":"Enums","text":"<p>Passing <code>Enum</code> values as argument is straight forward. They are handled just like any other type.</p> <p>There is just a single caveat, when it comes to the help output. If the default <code>__str__</code> method of the enum is used, the help output will not display the values bur rather the names. A simple solution is hence to overwrite <code>__str__</code> so that the value is printed. (Note: From Python 3.11 onwards, the <code>StrEnum</code> class does that automatically.)</p> <p>For Python versions prior to 3.12 it also makes sense to overwrite <code>__repr__</code> to print the value, as <code>repr</code> is used to generate the error output.</p> enum_arguments.py<pre><code>from enum import Enum\n\nimport typed_argparse as tap\n\n\nclass Color(Enum):\n    RED = 1\n    GREEN = \"green\"\n\n    def __str__(self) -&gt; str:\n        return str(self.value)\n\n\nclass Make(Enum):\n    BIG = 1\n    SMALL = \"small\"\n\n\nclass Args(tap.TypedArgs):\n    color: Color\n    make: Make\n\n\ndef runner(args: Args):\n    print(f\"Running my app with args:\\n{args}\")\n\n\ndef main() -&gt; None:\n    tap.Parser(Args).bind(runner).run()\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>Compare the help output for the two different enums:</p> <pre><code>$ python enum_arguments.py --help\nusage: enum_arguments.py [-h] --color {1,green} --make {Make.BIG,Make.SMALL}\n\noptions:\n  -h, --help            show this help message and exit\n  --color {1,green}\n  --make {Make.BIG,Make.SMALL}\n\n$ python examples/high_level_api/enum_arguments.py --color green --make 1\nRunning my app with args:\nArgs(color=&lt;Color.GREEN: 'green'&gt;, make=&lt;Make.BIG: 1&gt;)\n</code></pre>"},{"location":"low_level_api/","title":"Low-level API","text":""},{"location":"low_level_api/#motivation","title":"Motivation","text":"<p>Want to add type annotations to a code base that makes use of <code>argparse</code> without refactoring all you CLIs? <code>typed_argparse</code>'s low-level API allows to do that with minimal changes:</p> <ol> <li>Add a type <code>Args(TypedArgs)</code> that inherits from <code>TypedArgs</code> and fill it with type annotations.</li> <li>Wrap the result of e.g. your <code>parse_args</code> function with <code>Args</code>.</li> <li>That's it, enjoy IDE auto-completion and strong type safety \ud83d\ude00.</li> </ol> <p>Note</p> <p>If you plan to write a new CLI from scratch, consider using the high-level API instead.</p>"},{"location":"low_level_api/#usage","title":"Usage","text":"basic_usage.py<pre><code>import argparse\nimport sys\nfrom typing import List, Optional\n\nfrom typed_argparse import TypedArgs\n\n\n# Step 1: Add an argument type.\nclass Args(TypedArgs):\n    foo: str\n    num: Optional[int]\n    files: List[str]\n\n\ndef parse_args(args: List[str] = sys.argv[1:]) -&gt; Args:\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"--foo\", type=str, required=True)\n    parser.add_argument(\"--num\", type=int)\n    parser.add_argument(\"--files\", type=str, nargs=\"*\")\n    # Step 2: Wrap the plain argparser result with your type.\n    return Args.from_argparse(parser.parse_args(args))\n\n\ndef main() -&gt; None:\n    args = parse_args()\n    # Step 3: Done, enjoy IDE auto-completion and strong type safety\n    assert args.foo == \"foo\"\n    assert args.num == 42\n    assert args.files == [\"a\", \"b\", \"c\"]\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p><code>typed_argparse</code> validates that no attributes from the type definition are missing, and that no unexpected extra types are present in the <code>argparse.Namespace</code> object. It also validates the types at runtime. Therefore, if the <code>Args.from_argparse(args)</code> doesn't throw a <code>TypeError</code> you can be sure that your type annotation is correct.</p>"},{"location":"low_level_api/#feature-examples","title":"Feature Examples","text":""},{"location":"low_level_api/#convenience-functionality-to-map-literalenum-to-choices","title":"Convenience functionality to map Literal/Enum to choices","text":"<p>When defining arguments that should be limited to certain values, a natural choice for the corresponding type is to use either <code>Literal</code> or <code>Enum</code>. On argparse side, the corresponding setting is to specify the <code>choices=...</code> parameter. In order to have a single source of truth (i.e., avoid having to specify the values twice), it is possible to use <code>TypedArgs.get_choices_from()</code>. For instance:</p> <pre><code>class Args(TypedArgs):\n    mode: Literal[\"a\", \"b\", \"c\"]\n\n\ndef parse_args(args: List[str] = sys.argv[1:]) -&gt; Args:\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\n        \"--mode\",\n        type=str,\n        required=True,\n        choices=Args.get_choices_from(\"mode\"),\n    )\n    return Args.from_argparse(parser.parse_args(args))\n</code></pre> <p>This makes sure that <code>choices</code> is always in sync with the values allowed by <code>Args.mode</code>. The same works when using <code>mode: SomeEnum</code> where <code>SomeEnum</code> is an enum inheriting <code>enum.Enum</code>.</p> <pre><code>class MyEnum(Enum):\n    a = \"a\"\n    b = \"b\"\n    c = \"c\"\n\n\nclass Args(TypedArgs):\n    mode: MyEnum\n\n\ndef parse_args(args: List[str] = sys.argv[1:]) -&gt; Args:\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\n        \"--mode\",\n        type=MyEnum,\n        required=True,\n        choices=Args.get_choices_from(\"mode\"),\n    )\n    return Args.from_argparse(parser.parse_args(args))\n</code></pre>"},{"location":"low_level_api/#support-for-union-useful-for-subcommand-parsing","title":"Support for Union (useful for subcommand parsing)","text":"<p>When implementing multi command CLIs, the various subparsers can often have completely different arguments. In terms of the type system such arguments are best modelled as a <code>Union</code> type. For instance, consider a CLI that has two modes <code>foo</code> and <code>bar</code>. In the <code>foo</code> mode, we want a <code>--file</code> arg, but in the <code>bar</code> mode, we want e.g. a <code>--src</code> and <code>--dst</code> args. We also want some shared args, like <code>--verbose</code>. This can be achieved by modeling the types as:</p> <pre><code>from typed_argparse import TypedArgs, WithUnionType\n\n\nclass CommonArgs(TypedArgs):\n    verbose: bool\n\n\nclass ArgsFoo(CommonArgs):\n    mode: Literal[\"foo\"]\n    file: str\n\n\nclass ArgsBar(CommonArgs):\n    mode: Literal[\"bar\"]\n    src: str\n    dst: str\n\n\nArgs = Union[ArgsFoo, ArgsBar]\n</code></pre> <p>On parsing side, <code>WithUnionType[Args].validate(...)</code> can be used to parse the arguments into a type union:</p> <pre><code>def parse_args(args: List[str] = sys.argv[1:]) -&gt; Args:\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"--verbose\", action=\"store_true\", help=\"Verbose\")\n    subparsers = parser.add_subparsers(\n        help=\"Available sub commands\",\n        dest=\"mode\",\n        required=True,\n    )\n\n    parser_foo = subparsers.add_parser(\"foo\")\n    parser_foo.add_argument(\"file\", type=str)\n\n    parser_bar = subparsers.add_parser(\"bar\")\n    parser_bar.add_argument(\"--src\", required=True)\n    parser_bar.add_argument(\"--dst\", required=True)\n\n    return WithUnionType[Args].validate(parser.parse_args(args))\n</code></pre> <p>Type checkers like mypy a pretty good at handling such \"tagged unions\". Usage could look like:</p> <pre><code>def main() -&gt; None:\n    args = parse_args()\n\n    if args.mode == \"foo\":\n        # In this branch, mypy knows (only) these fields (and their types)\n        print(args.file, args.verbose)\n\n    if args.mode == \"bar\":\n        # In this branch, mypy knows (only) these fields (and their types)\n        print(args.src, args.dst, args.verbose)\n\n    # Alternatively:\n    if isinstance(args, ArgsFoo):\n        # It's an ArgsFoo\n        ...\n    if isinstance(args, ArgsBar):\n        # It's an ArgsBar\n        ...\n</code></pre>"},{"location":"low_level_api/#work-around-for-common-argparse-limitation","title":"Work-around for common argparse limitation","text":"<p>A known limitation (bug report, SO question 1, SO question 2) of argparse is that it is not possible to combine a positional <code>choices</code> parameters with <code>nargs=\"*\"</code> and an list-like default. This may sounds exotic, but isn't such a rare use case in practice. Consider for instance a positional <code>actions</code> argument that should take the values \"eat\" and \"sleep\" and allow for arbitrary sequences \"eat eat sleep eat ...\". The library provides a small work-around wrapper class <code>Choices</code> that allows to work-around this argparse limitation:</p> <pre><code>from typed_argparse import Choices\n\ndef parse_args():\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\n        \"actions\",\n        nargs=\"*\",\n        choices=Choices(\"eat\", \"sleep\"),\n        default=[],\n    )\n</code></pre> <p><code>TypedArgs.get_choices_from()</code> internally uses this wrapper, i.e., it automatically solves the limitation.</p>"}]}